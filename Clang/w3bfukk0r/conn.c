/*
 * (C)opyright 2006 Nico Golde <nico@ngolde.de>
 * (C)opyright 2006 Andreas Krennmair <ak@synflood.at>
 * See LICENSE file for license details
 */

#include "conn.h"

#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <unistd.h>
#include <stdlib.h>

/* OpenSSL headers */
#include <openssl/ssl.h>
#include <openssl/bio.h>

static void conn_init_ssl(conn_t * );

static inline int conn_read_plain(conn_t * conn, char * buf, size_t bufsize) {
	if (conn && buf && bufsize >= 0) {
		return read(conn->fd,buf,bufsize);
	}
	return -1;
}

static inline int conn_write_plain(conn_t * conn, char * buf, size_t bufsize) {
	if (conn && buf && bufsize >= 0) {
		return write(conn->fd,buf,bufsize);
	}
	return -1;
}

static inline int conn_read_ssl(conn_t * conn, char * buf, size_t bufsize) {
	if (conn && conn->hndl && buf && bufsize >= 0) {
		return SSL_read((SSL *)conn->hndl,buf,bufsize);
	}
	return -1;
}

static inline int conn_write_ssl(conn_t * conn, char * buf, size_t bufsize) {
	if (conn && conn->hndl && buf && bufsize >= 0) {
		return SSL_write((SSL *)conn->hndl,buf,bufsize);
	}
	return -1;
}

conn_t * connect_plain(char * ip, uint16_t port) {
	struct addrinfo hint, *res;
	int sockfd;
	int error;
	char cport[5];
	conn_t * conn;

	conn = malloc(sizeof(conn_t));
	snprintf(cport, sizeof(cport), "%d", port);
	if (!conn) {
		perror("malloc");
		return NULL;
	}

	memset(&hint,0,sizeof(hint));
	hint.ai_family = AF_INET;
	hint.ai_socktype = SOCK_STREAM;

	if((error=getaddrinfo(ip, cport, &hint, &res))!=0){
		fprintf(stderr,"getaddrinfo: %s\n",gai_strerror(error));
		exit(EXIT_FAILURE);
	}
	if ((sockfd=socket(res->ai_family, res->ai_socktype, res->ai_protocol))==-1) {
		free(conn);
		exit(EXIT_FAILURE);
	}
	if (connect(sockfd,res->ai_addr, sizeof(struct sockaddr_in)) < 0) {
		perror("connect");
		exit(EXIT_FAILURE);
	}

	conn->fd = sockfd;
	conn->hndl = NULL;
	conn->type = CONN_PLAIN;
	freeaddrinfo(res);
	return conn;
}

conn_t * connect_ssl_proxy(char * proxyip, uint16_t proxyport, char * ip, uint16_t port) {
	conn_t * conn = connect_plain(proxyip,proxyport);
	char buf[1024];
	int len;
	unsigned int http_resp_code = 0;
	int check_resp = 1;
	char c = 0;

	if (!conn) {
		fprintf(stderr,"error: connection to proxy failed\n");
		exit(EXIT_FAILURE);
	}

	snprintf(buf,sizeof(buf),"CONNECT %s:%u HTTP/1.0\r\n\r\n",ip,port);

	conn_write(conn,buf,strlen(buf));

	do {
		len = conn_readline(conn,buf,sizeof(buf));
		if (len>=0) { 
			buf[len] = '\0';
			if (check_resp) {
				if (sscanf(buf,"HTTP/1.%c %u",&c,&http_resp_code)!=2) {
					disconnect(conn);
					fprintf(stderr,"error: HTTP proxy returned invalid response for CONNECT command.\n");
					exit(EXIT_FAILURE);
				}
				check_resp = 0;
			}
		}
	} while (len > 0 && strcmp(buf,"\r\n")!=0);

	if (http_resp_code != 200) {
		fprintf(stderr,"error: HTTP proxy returned response code %u for CONNECT command.\n",http_resp_code);
		exit(EXIT_FAILURE);
	}

	conn_init_ssl(conn);
	
	return conn;
}

conn_t * connect_ssl(char * ip, uint16_t port) {
	conn_t * conn = connect_plain(ip, port);

	conn_init_ssl(conn);
	return conn;
}

static void conn_init_ssl(conn_t * conn) {
	SSL_CTX * ctx;
	SSL * ssl;

	SSL_load_error_strings();
	SSLeay_add_ssl_algorithms();

	if (!conn) {
		fprintf(stderr,"connect_ssl: conn is NULL\n");
		exit(EXIT_FAILURE);
	}

	ctx = SSL_CTX_new(SSLv23_client_method());
	if (!ctx) { 
		fprintf(stderr,"SSL_ctx_new failed!\n");
		disconnect(conn); 
		exit(EXIT_FAILURE);
	}

	ssl = SSL_new(ctx);
	if (!ssl) { 
		fprintf(stderr,"SSL_new failed!\n");
		disconnect(conn); 
		SSL_CTX_free(ctx);
		exit(EXIT_FAILURE);
	}

	SSL_set_fd(ssl,conn->fd);

	if (SSL_connect(ssl)<=0) {
		fprintf(stderr,"SSL_connect failed!\n");
		disconnect(conn);
		SSL_free(ssl);
		exit(EXIT_FAILURE);
	}

	conn->type = CONN_SSL;
	conn->hndl = ssl;
}

void disconnect(conn_t * conn) {
	if (conn) {
		switch (conn->type) {
			case CONN_PLAIN:
				shutdown(conn->fd,SHUT_RDWR);
				close(conn->fd);
				break;
			case CONN_SSL:
				if (conn->hndl) {
					SSL_shutdown((SSL *)conn->hndl);
					SSL_free((SSL *)conn->hndl);
					conn->type = CONN_PLAIN;
					disconnect(conn);
					return;
				}
			default:
				break;
		}
		free(conn);
	}
}

int conn_read(conn_t * conn, char * buf, size_t bufsize) {
	if (conn) {
		switch (conn->type) {
			case CONN_PLAIN:
				return conn_read_plain(conn,buf,bufsize);
			case CONN_SSL:
				return conn_read_ssl(conn,buf,bufsize);
				break;
			default:
				return -1;
		}
	}
	return -1;
}

int conn_write(conn_t * conn, char * buf, size_t bufsize) {
	if (conn) {
		switch (conn->type) {
			case CONN_PLAIN:
				return conn_write_plain(conn,buf,bufsize);
			case CONN_SSL:
				return conn_write_ssl(conn,buf,bufsize);
				break;
			default:
				return -1;
		}
	}
	return -1;
}

int conn_readline(conn_t * conn, char * buf, size_t bufsize) {
	size_t i = 0;
	char c;
	int stopread = 0;
	int s;
	while (i<bufsize && !stopread) {
		s = conn_read(conn,&c,1);
		if (s > 0) {
			buf[i] = c;
			++i;
			if (c == '\n') {
				stopread = 1;
			}
		} else {
			stopread = 1;
		}
	}
	return i;
}
