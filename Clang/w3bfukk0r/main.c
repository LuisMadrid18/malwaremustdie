/*
 * (C)opyright 2006 Nico Golde <nico@ngolde.de>
 * (C)opyright 2006 Andreas Krennmair <ak@synflood.at>
 * See LICENSE file for license details
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>
#include <string.h>

#include "list.h"
#include "conn.h"
#include "url.h"
#include "http.h"

static void usage(char * argv0) {
	fprintf(stderr, "%s " VERSION "\nusage: %s -f <wordsfile> [-p <host>:<port>] [-o <file>] <URL> [<URL> ...]\n",argv0,argv0);
	fprintf(stderr, "options:\n"
					"-h    display this help\n"
					"-f    specify wordlist file\n"
					"-v    more verbose output\n"
					"-u    fake user agent header\n"
                    "-p    specify proxy host and port\n"
					"-o    write output to file\n");
	exit(EXIT_FAILURE);
}

int main(int argc, char * argv[]) {
	char * wordfile = "words.txt";
	char * url = NULL;
	char * optstr = "f:hvuo:p:";
	char * outfile = NULL;
	uint16_t proxyport = 8080;
	char * proxyhost = NULL;
	char service[1024] = "";
	wordlist_t * wl;
	int c;
	int status = 404;
	int verbose = 0, fake_ua = 0;
	time_t t1, t2;
	FILE * logf = NULL;

	t1 = time(NULL);

	do {
		c = getopt(argc,argv,optstr);
		if (c < 0) continue; switch (c) {
			case ':': /* fall-through */
			case '?': /* missing option */
				exit(EXIT_FAILURE);
			case 'f':
				wordfile = optarg;
				break;
			case 'h': 
				usage(argv[0]);
				break;
			case 'v':
				verbose = 1;
				break;
			case 'u':
				fake_ua = 1;
				break;
			case 'o':
				outfile = optarg;
				break;
			case 'p':
				proxyhost = optarg;
				proxyport = getport(proxyhost);
				break;
			default:
				fprintf(stderr,"%s: unknown option: -%c\n",argv[0],c);
				exit(EXIT_FAILURE);
		};
	} while (c != -1);

	if (optind >= argc) {
		fprintf(stderr,"%s: missing URL\n",argv[0]);
		usage(argv[0]);
	}

	if (!wordfile) {
		fprintf(stderr,"%s: wordfile not specified\n",argv[0]);
		usage(argv[0]);
	}

	if (outfile) {
		logf = fopen(outfile,"w");
	}

	printf("Starting w3bfukk0r " VERSION "\n");
	if (logf) {
		fprintf(logf,"Starting w3bfukk0r " VERSION "\n");
	}

	wl = new_wordlist();
	fill_wordlist_from_file(wl,wordfile);

	/* code to demonstrate usage of connections: */
	for (url=argv[optind];optind<argc;url=argv[++optind]) {
		conn_t * conn = NULL;
		url_t * u = parse_url(url);
		word_t * e;
		int local_count = 0;
		char buf[1024];
		char nice_url[1024];
		char proxy_resource[1024];
		ssize_t s;
		int reconnect = 1, force_disconnect = 0;
		unsigned long found_counter = 0;

		if (!u) {
			fprintf(stderr,"couldn't parse URL `%s'\n",url);
			if (logf) {
				fprintf(logf,"couldn't parse URL `%s'\n",url);
			}
			exit(EXIT_FAILURE);
		}

		url_to_str(nice_url,sizeof(nice_url),u);

		if(proxyhost){
			proxyresource(proxy_resource, sizeof(proxy_resource), nice_url, u->resource);
			u->resource=strdup(proxy_resource);
		}

		printf("Scanning %s with %lu words from %s\n\n",nice_url,wl->count,wordfile);
		if (logf) {
			fprintf(logf,"Scanning %s with %lu words from %s\n\n",nice_url,wl->count,wordfile);
		}

		for (e=wl->top;e;e=e->next) {
			char * word = e->word;

			if (reconnect) {
				if(u->protocol == PROTO_HTTP){
					if(proxyhost)
						conn = connect_plain(proxyhost, proxyport);
					else
						conn = connect_plain(u->host, u->port);
				} else {
					if(proxyhost)
						conn = connect_ssl_proxy(proxyhost, proxyport, u->host, u->port);
					else
						conn = connect_ssl(u->host, u->port);
				}
				if (!conn) {
					fprintf(stderr,"error: connection failed\n"); 
					if (logf) {
						fprintf(logf,"error: connection failed\n");
					}
					exit(EXIT_FAILURE); 
				}
				reconnect = 0;
			}
			if (local_count < wl->count) {
				send_head_request(conn, u, word, KEEPALIVE | (fake_ua ? FAKE_UA : 0));
			} else {
				send_head_request(conn, u, word, 0 | (fake_ua ? FAKE_UA : 0));
			}
			local_count++;

			s=conn_readline(conn,buf,sizeof(buf)-1);
			if (s > 0) {
				buf[s] = '\0';
				status=parse_http(buf);
				if (status == 403) {
					printf("Found %s%s/ (not public; HTTP %u)\n", nice_url, word, status);
					if (logf) {
						fprintf(logf,"Found %s%s/ (not public; HTTP %u)\n", nice_url, word, status);
					}
					++found_counter;
				} else if(status >= 400 && status <= 499) {
					if (verbose) {
						printf("Does not exist: %s%s/ (HTTP %u)\n", nice_url, word, status);
						if (logf) {
							fprintf(logf,"Does not exist: %s%s/ (HTTP %u)\n", nice_url, word, status);
						}
					}
				} else if(status >= 200 && status <= 299) {
					printf("Found %s%s/ (HTTP %u)\n", nice_url, word, status);
					if (logf) {
						fprintf(logf,"Found %s%s/ (HTTP %u)\n", nice_url, word, status);
					}
					++found_counter;
				} else {
					if (verbose) {
						printf("Other response code: %s%s/ (HTTP %u)\n",nice_url, word, status);
						if (logf) {
							fprintf(logf,"Other response code: %s%s/ (HTTP %u)\n",nice_url, word, status);
						}
					}
				}

				do {
					s=conn_readline(conn,buf,sizeof(buf)-1);
					buf[s] = '\0';
					if (strcasecmp(buf,"connection: close\r\n")==0) {
						force_disconnect = 1;
					}
					if(!strncasecmp(buf, "Server: ", 8))
						snprintf(service, sizeof(service), "%s", get_service(buf));
				} while ((s > 0) && (strcmp(buf,"\r\n")!=0));
			}
			
			if (local_count < wl->count && (s == 0 || force_disconnect)) {
				force_disconnect = 0;
				disconnect(conn);
				reconnect = 1;
			}
		}
		disconnect(conn);
		free_url(u);

		printf("\nFound %lu directories.\n",found_counter);
		printf("Server runs: %s\n", strlen(service)>0 ? service : "can not be determined");
		if (logf) {
			fprintf(logf,"\nFound %lu directories.\n",found_counter);
			fprintf(logf,"Server runs: %s\n", strlen(service)>0 ? service : "can not be determined");
		}

	}

	t2 = time(NULL);

	printf("Scan finished (%lu seconds).\n",t2-t1);
	if (logf) {
		fprintf(logf,"Scan finished (%lu seconds).\n",t2-t1);
		fclose(logf);
	}
	delete_list(wl);
	return 0;
}
